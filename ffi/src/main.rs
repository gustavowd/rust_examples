use std::os::raw::c_char;
use std::ffi::CString;
use std::thread;
use std::time::Duration;

// this extern block links to the libm library
#[link(name = "serial")]
extern "C" {
    // this is a foreign function
    fn serialOpen (device: *const c_char, baud: i32) -> i32;
    fn serialClose (fd: i32);
    //fn serialPutchar (fd: i32, str: c_char) -> i32;
    fn serialPutBuffer (fd: i32, data: *const u8, len: i32) -> i32;
    //fn serialPuts (fd: i32, data: *const c_char) -> i32;
    //fn serialDataAvail (fd: i32) -> i32;
    fn serialGetchar (fd: i32, data: *mut u8) -> i32;
}

const AUCCRCHI: [u8; 256] = [
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40];

const AUCCRCLO: [u8; 256] = [
    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
    0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
    0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
    0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
    0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
    0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
    0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
    0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 
    0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
    0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
    0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
    0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
    0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 
    0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
    0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
    0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
    0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
    0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
    0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
    0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
    0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
    0x41, 0x81, 0x80, 0x40
];

fn us_mbcrc16(puc_frame: &Vec<u8>, us_len: usize ) -> (u8, u8)
{
    let mut uc_crchi:u8 = 0xFF;
    let mut uc_crclo:u8 = 0xFF;
    let mut i_index;

    for i in 0..us_len {
        i_index = uc_crclo ^ puc_frame[i];
        let idx = i_index as usize;
        uc_crclo = uc_crchi ^ AUCCRCHI[idx];
        uc_crchi = AUCCRCLO[idx];
    }
    (uc_crclo, uc_crchi)
}


//Função para ler os input registers
fn read_input_reg(port: i32, endereco_slave: u8, mut init_address: u16, num_reg_read: u16, regs: &mut Vec<u16>) -> i32{

	let mut mensagem:Vec<u8> = vec![0; 8]; //vetor  mensagem
	let tamanho_resposta= 5+(2*num_reg_read);

	//monta vetor mensagem
	init_address -= 1;
	mensagem[0] = endereco_slave;
	mensagem[1] = 4;
	mensagem[2] = (init_address >> 8) as u8;
	mensagem[3] = (init_address & 0xFF) as u8;
	mensagem[4] = (num_reg_read >> 8) as u8;
	mensagem[5] = (num_reg_read & 0xFF) as u8;

	let crc = us_mbcrc16(&mensagem,6);

	mensagem[6] = crc.0;
	mensagem[7] = crc.1;

	// Transmite a pergunta
    unsafe {
        serialPutBuffer (port, mensagem.as_mut_ptr(), 8);
    }

    let mut resposta:Vec<u8> = vec![0; tamanho_resposta as usize]; //vetor  resposta
    let mut data: Vec<u8> = vec![0];

	/* Recebe a resposta */
    unsafe {
	    serialGetchar (port, data.as_mut_ptr());
    }
    // endereço
    resposta[0] = data[0];
    if resposta[0] != endereco_slave {
		return -1;
	}

    unsafe {
	    serialGetchar (port, data.as_mut_ptr());
    }
    // função
    resposta[1] = data[0];
	if resposta[1] != 4 {
		return -1;
	}

	for j in 2..tamanho_resposta as usize{
        unsafe {
            serialGetchar (port, data.as_mut_ptr());
        }
        resposta[j] = data[0];
	}

	// Teste de CRC
	let crc = us_mbcrc16(&resposta,tamanho_resposta as usize - 2);

	if crc.0 == resposta[tamanho_resposta as usize - 2] &&  crc.1 == resposta[tamanho_resposta as usize - 1]{
        let iter_size = ((tamanho_resposta - 5) >> 1) as usize;
        for i in 0..iter_size {
			regs[i] =  ((resposta[3+(i*2)] as u16) << 8) | resposta[4+(i*2)] as u16;
		}
		return 0;
	}
	-1
}//fim da função de leitura dos input registers
 

fn main() {
    println!("Teste de porta serial");
    let port_name = CString::new(r#"/dev/ttyACM0"#).expect("CString::new failed");
    println!("Abrindo a porta {}", port_name.to_string_lossy());
    let port;
    unsafe {
        port = serialOpen(port_name.as_ptr(), 115200);
    }
    println!("Numero da porta: {}", port);
    if port < 0 {
        return;
    }

    let number_of_regs = 10;
    let mut received:Vec<u16> = vec![0; number_of_regs];
    let mut received_float:Vec<f32> = vec![0.0; number_of_regs];
    loop {
        if read_input_reg(port, 10, 50000, number_of_regs as u16, &mut received) >= 0{
            for i in 0..received_float.len() {
                received_float[i] = received[i] as f32;
                received_float[i] = received_float[i] * 0.000805861;
                
                received_float[i] = received[i] as f32;
                received_float[i] = received_float[i] * 0.000805861;
            }
            println!("Dado reccebido: {:?}", received_float);
            thread::sleep(Duration::new(0, 100000000));  
        }else{
            unsafe {
                serialClose(port);
            }
            break;
        }
    }
}
